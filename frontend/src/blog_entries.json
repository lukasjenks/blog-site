[
	{"date": "2021-03-01",
	 "entryText": "\tThe practice of whiteboarding as part of the interviewing process in the development space is an interestingly controversial one. While some companies seem to dislike and avoid it quite a bit, believing it to be a better judge of a candidates' performance anxiety rather than their proficiency with software engineering, I, for one, am undecided. I know that for me, in my very minimal experience of going through only two whiteboard interviews, nerves and performance anxiety have often gotten the best of me. I'll \"freeze up\" at specific points, blankly staring at the code I'm writing as if it's a foreign language, whereas if I were to be solving the same problem at home on LeetCode, it would be just another fun, everyday exercise. When asked about the time complexity of an algorithm I just wrote, for example, I may freeze up and barely process the question before my mind races and haphazardly parses through the code I have just written, which naturally leads to a frantic and wrong, or flawed answer. Of course, these mistakes become exceedingly clear directly after the interview, when the pressure to succeed is gone, and I mull over the problem in my head afterward, free of stress. Being aware of this is undoubtedly important as all this having been said, if not whiteboarding, what is more appropriate?\n\n\tI've lately been working towards improving my skills in this area, but the question remains; Should we as developers practice active listening and critical thinking in stressful situations to simply better prepare for these situations and accept whiteboarding as the industry standard? Should companies rely instead on take-home assessments and theory-based questions? One thing I've found myself enjoying quite a bit that surprised me is contributing to the hiring process for developers at my current company; Screening applicants, developing the take home assessment, and trying to mitigate the factors I listed above. I think if a whiteboarding approach is taken, while it is something the candidate needs to strive towards overcoming, it's reasonable to assume that the candidate may be experiencing quite a bit of performance anxiety and be performing suboptimally when given on the spot questions. I know for me, if an interviewer is to simply ask: \"Are you sure about that?\" or something along those lines, I will immediately re-think an answer more carefully, and subsequently respond with a better response, at least a bit less plagued by a silly mistake that I'll regret when thinking about how the interview went directly after.\n\n\tPart of what prompted me to think about this was having the summary of an academic study on this topic (believe it or not) appear in my suggested articles in Firefox, which I'll link below. Essentially, what the researchers found was along the lines of what I talked about here; Whiteboard interviews, as often executed today, do a better job of assessing whether a job candidate has performance anxiety rather than their software engineering competence.\n\n\tI think there is some value to whiteboard interviews (despite their flaws). Being aware of and mitigating the effect of anxiety on one's thought process during them is something I'm working on getting better at. How else can you observe a candidate's thought process when developing an algorithm in real-time, even if that thought process is influenced by anxiety? There isn't an immediately straightforward and easy way to completely mitigate this issue; However, I think these factors I have mentioned and are mentioned by the study linked below do in the least have to be kept in mind during a company's hiring process. They are certainly something that I'll be keeping in mind during my companies upcoming interviewing sessions.",
	 "media": {"links": ["https://www.sciencedaily.com/releases/2020/07/200714101228.htm"]}
	},
	{"date": "2020-12-07",
	 "entryText": "\tI've been intruiged by the process of encoding/decoding data in audio ever since being fascinated as a kid with how a Commodore 64 would load games from an audio cassette. Of course, now that I know the \"Commodore Datasette\" as it is called used a simple circuit in the tape unit to convert the basic analog signal into 1's and 0's based on timing in the sound's waveform (which explains why it took so damn long to load a game), the childhood \"magic\" of loading a game from an audio cassette is gone, but remains nostalgic for me. This is probably why when I saw this article about booting DOS on an IBM 5150 from a vinyl record encoded with an analog recording of a bootable read-only 64K RAM drive, I couldn't help but smile.\n\n\tThis is clearly not the most useful project, but one I consider worthwhile. Not simply for the enjoyment of the programmer and for the fact that its extremely interesting to read about for someone like me, but because I've found that by exploring and learning about past technologies and langauages you build contextual knowledge which makes one a better programmer. Maybe not by a lot and perhaps only subtly depending on what the technology is, but worthwhile nonetheless.\n\n\tWriting about this reminds me of learning the programming language Lisp and functional programming in general in my non-procedural programming class during my undergrad. While functional programming is becoming more and more prevalent and useful in modern software programming practices today, Lisp is certainly not the most actively utilized language nowadays, with the notable exception of quantum computing recently (and certainly not much at all commercially). That being said, I think that learning functional programming with this language benefitted me greatly as a programmer, and I came out of that class with a more robust programming style than I came in with. The language's usage of s expressions and its resulting fusion of code and data make it the perfect language to learn, and fully understand functional programming, in my opinion. Beyond that, learning the language simply gives the programmer a better context for what came before, and how programming has evolved into its procedural-focused, C-family (of languages) dominated landscape today.",
	 "media": {"links": ["http://boginjr.com/it/sw/dev/vinyl-boot/"]}
	},

	{"date": "2020-08-25",
	 "entryText": "\tAfter taking quite the break from Unity (I haven't worked with it in a good while), I came across some posts showing what has been/what's being added to the engine lately and I'm impressed; it's really interesting stuff - particularily what they're doing with their new DOTS framework and \"Burst Compiler\". DOTS is supposed to make it much easier to allow games to make use of multicore processors and multithreading in general, while their \"Burst Compiler\" utilizes JIT compilation to allow C# Unity code to run essentially as fast or faster than if it were written in C++ (just what I've heard). I have to say I'm skeptical about that last part but am eager to dive back into Unity at least for a while to see if this is true. I was looking for a reason to lately anyways.",
	"media": {"videos": ["https://www.youtube.com/watch?v=Z9-WkwdDoNY"]}
	},

	{"date": "2020-08-23",
	 "entryText": "\tI've finally put together a blog/portfolio site! It took very little time to put together, but was just one of those things I never prioritized or got around to. While it's not stylized quite how I'd like, it'll work for now. I can always refresh it later - I had been meaning to try out semantic UI as opposed to bootstrap and material UI anyways, so that would provide for a good excuse to do so."
	}
]
