[
	{"date": "2020-12-07",
	 "entryText": "\tI've been intruiged by the process of encoding/decoding data in audio ever since being fascinated as a kid with how a Commodore 64 would load games from an audio cassette. Of course, now that I know the \"Commodore Datasette\" as it is called used a simple circuit in the tape unit to convert the basic analog signal into 1's and 0's based on timing in the sound's waveform (which explains why it took so damn long to load a game), the childhood \"magic\" of loading a game from an audio cassette is gone, but remains nostalgic for me. This is probably why when I saw this article about booting DOS on an IBM 5150 from a vinyl record encoded with an analog recording of a bootable read-only 64K RAM drive, I couldn't help but smile.\n\tThis is clearly not the most useful project, but one I consider worthwhile. Not simply for the enjoyment of the programmer and for the fact that its extremely interesting to read about for someone like me, but because I've found that by exploring and learning about past technologies and langauages you build contextual knowledge which makes one a better programmer. Maybe not by a lot and perhaps only subtly depending on what the technology is, but worthwhile nonetheless.\n\tWriting about this reminds me of learning the programming language Lisp and functional programming in general in my non-procedural programming class during my undergrad. While functional programming is becoming more and more prevalent and useful in modern software programming practices today, Lisp is certainly not the most actively utilized language nowadays, with the notable exception of quantum computing recently (and certainly not much at all commercially). That being said, I think that learning functional programming with this language benefitted me greatly as a programmer, and I came out of that class with a more robust programming style than I came in with. The language's usage of s expressions and its resulting fusion of code and data make it the perfect language to learn, and fully understand functional programming, in my opinion. Beyond that, learning the language simply gives the programmer a better context for what came before, and how programming has evolved into its procedural-focused, C-family (of languages) dominated landscape today.",
	 "media": {"links": ["http://boginjr.com/it/sw/dev/vinyl-boot/"]}
	},

	{"date": "2020-08-25",
	 "entryText": "After taking quite the break from Unity (I haven't worked with it in a good while), I came across some posts showing what has been/what's being added to the engine lately and I'm impressed; it's really interesting stuff - particularily what they're doing with their new DOTS framework and \"Burst Compiler\". DOTS is supposed to make it much easier to allow games to make use of multicore processors and multithreading in general, while their \"Burst Compiler\" utilizes JIT compilation to allow C# Unity code to run essentially as fast or faster than if it were written in C++ (just what I've heard). I have to say I'm skeptical about that last part but am eager to dive back into Unity at least for a while to see if this is true. I was looking for a reason to lately anyways.",
	"media": {"videos": ["https://www.youtube.com/watch?v=Z9-WkwdDoNY"]}
	},

	{"date": "2020-08-23",
	 "entryText": "I've finally put together a blog/portfolio site! It took very little time to put together, but was just one of those things I never prioritized or got around to. While it's not stylized quite how I'd like, it'll work for now. I can always refresh it later - I had been meaning to try out semantic UI as opposed to bootstrap and material UI anyways, so that would provide for a good excuse to do so."
	}
]
