[
	{"date": "2021-03-01",
	 "entryText": "\\tThe practice of whiteboarding as the interviewing process in the development space is an interestingly controversial one. While some companies seem to dislike and avoid it quite a bit, believing it to be a better judge of a candidates' performance anxiety rather than their proficiency with software engineering. I for one am undecided. I know that for me personally in my extremely limited experience of going through only 2 whiteboard interviews, nerves have gotten the best of me and I'll \"freeze up\", at certain points, blankly staring at the code I'm writing as if it's a foreign language. When asked about the time complexity of an algorithm I just wrote for example, I may freeze up and barely process the question before my mind will race and parse through the code in a haphazard way, which naturally leads to a frantic and wrong answer. Of course, these mistakes become exceedingly clear directly after the interview, when the pressure to succeed is gone and I mull over the problem in my head afterwards, free of pressure.\\n\\tAll this being said, if not whiteboarding, what is more appropriate? Should we as developers simply practice active listening and critical thinking in stressful situations to better prepare? Should companies rely instead on take-home assessments and questions based on theory? One thing I've found myself enjoying quite a bit that surprised me is the amount of fun it's been contributing to the hiring process at my current company; Screening applicants, developing the take home assessment, and trying to mitigate for the factors I listed above. I think if a whiteboarding approach is taken, while it is something the candidate needs to strive towards overcoming, it's reasonable to assume that the candidate may be experiencing quite a bit of performance anxiety and be performing suboptimally when given on the spot questions. I know for me, if an interviewer is to simply ask: \"Are you sure about that?\" or something along those lines, I will immediately re-think an answer more carefully, and subsequently respond with a better answer, at least a bit less plagued by a silly answer that I'll regret later, when thinking about how the interview went.\\n\\tPart of what prompted me to think about this was having the summary of an academic study on this topic (believe it or not) appear in my suggested articles in Firefox which I'll link below. Essentially, what the researchers found was along the lines of what I talked about here; Whiteboard interviews as they're executed often today assess whether a job candidate has performance anxiety rather than their software engineering competence. While I think there is value to whiteboard interviews, (how else can you observe a candidate's thought process when developing an algorithm in real time, even if that thought process is influenced by anxiety?), and there isn't an immediately easy way to mitigate this issue completely, I do think these factors at least has to be kept in mind during a companies hiring process, and something that I'll be keeping in mind during my companies upcoming interviewing sessions.",
	 "media": {"links": ["https://www.sciencedaily.com/releases/2020/07/200714101228.htm"]}
	},
	{"date": "2020-12-07",
	 "entryText": "\\tI've been intruiged by the process of encoding/decoding data in audio ever since being fascinated as a kid with how a Commodore 64 would load games from an audio cassette. Of course, now that I know the \"Commodore Datasette\" as it is called used a simple circuit in the tape unit to convert the basic analog signal into 1's and 0's based on timing in the sound's waveform (which explains why it took so damn long to load a game), the childhood \"magic\" of loading a game from an audio cassette is gone, but remains nostalgic for me. This is probably why when I saw this article about booting DOS on an IBM 5150 from a vinyl record encoded with an analog recording of a bootable read-only 64K RAM drive, I couldn't help but smile.\n\tThis is clearly not the most useful project, but one I consider worthwhile. Not simply for the enjoyment of the programmer and for the fact that its extremely interesting to read about for someone like me, but because I've found that by exploring and learning about past technologies and langauages you build contextual knowledge which makes one a better programmer. Maybe not by a lot and perhaps only subtly depending on what the technology is, but worthwhile nonetheless.\\n\\tWriting about this reminds me of learning the programming language Lisp and functional programming in general in my non-procedural programming class during my undergrad. While functional programming is becoming more and more prevalent and useful in modern software programming practices today, Lisp is certainly not the most actively utilized language nowadays, with the notable exception of quantum computing recently (and certainly not much at all commercially). That being said, I think that learning functional programming with this language benefitted me greatly as a programmer, and I came out of that class with a more robust programming style than I came in with. The language's usage of s expressions and its resulting fusion of code and data make it the perfect language to learn, and fully understand functional programming, in my opinion. Beyond that, learning the language simply gives the programmer a better context for what came before, and how programming has evolved into its procedural-focused, C-family (of languages) dominated landscape today.",
	 "media": {"links": ["http://boginjr.com/it/sw/dev/vinyl-boot/"]}
	},

	{"date": "2020-08-25",
	 "entryText": "\\tAfter taking quite the break from Unity (I haven't worked with it in a good while), I came across some posts showing what has been/what's being added to the engine lately and I'm impressed; it's really interesting stuff - particularily what they're doing with their new DOTS framework and \"Burst Compiler\". DOTS is supposed to make it much easier to allow games to make use of multicore processors and multithreading in general, while their \"Burst Compiler\" utilizes JIT compilation to allow C# Unity code to run essentially as fast or faster than if it were written in C++ (just what I've heard). I have to say I'm skeptical about that last part but am eager to dive back into Unity at least for a while to see if this is true. I was looking for a reason to lately anyways.",
	"media": {"videos": ["https://www.youtube.com/watch?v=Z9-WkwdDoNY"]}
	},

	{"date": "2020-08-23",
	 "entryText": "\\tI've finally put together a blog/portfolio site! It took very little time to put together, but was just one of those things I never prioritized or got around to. While it's not stylized quite how I'd like, it'll work for now. I can always refresh it later - I had been meaning to try out semantic UI as opposed to bootstrap and material UI anyways, so that would provide for a good excuse to do so."
	}
]
